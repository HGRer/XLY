**Part1**

在虚拟机中，内存堆的作用是存放对象实例和数组。在Java进程运行的过程中，大量的实例对象会分配到堆上面，因此堆内存的回收与分配影响着程序的健康和运行效率。

不同的垃圾回收算法有着不同的应用场景，因此对堆的内存结构有着各自的理解。到学习到G1收集器为止，各GC均对堆采取了“分代设计”的思想。即根据根据实例存活的时间长度来区分该实例属于yound区还是old区。

young区管理新实例的分配。相对old区而言，实例存活时间短，即每次GC找到的无效实例较多，找到可释放的内存较多。

old区的实例存活时间长，每次GC计算实例引用的时间花费较长。

1.**serial收集器**，单线程，应用于young区，每次GC时回收全部可释放的内存。该收集器每次运行时会阻塞所有用户线程（即GC线程占用所有CPU资源），在单线程运行模式下GC效率不高，用户线程等待时间较长。

**压测结论**：针对GCLogAnalysis程序，堆内存在256m,512m,1g,4g的范围内压测。由于蓄水池效应，随着堆内存的递增，GC的频率逐渐减少，但是每次GC的花费的时间明显递增。同时因为young区大小的递增，发生majorGC和FullGC的次数也减少。

2.**serialOld收集器**，单线程，应用于Old区。serialOld收集器和serial收集器的结论类似，从书上了解到该收集器是CMS收集器的后备选择。

3.**ParNewGC**，多线程并行，应用于young区。ParNewGC和Serial收集器高度类似，但是ParNewGC是多线程运行的，各GC线程并行执行垃圾回收，同样会阻塞所有用户线程，占用全部CPU资源。在同样的堆内存配置下，随着堆内存的递增，ParNewGC运行的效率明显好于Serial收集器。当然，这个结论是运行在多核环境，如果在单核或者GC线程数量大幅度高于核心下，由于GC线程之间的竞争，不保证会有“ParNewGC运行的效率明显好于Serial收集器”这个结论。

**压测结论**：针对GCLogAnalysis程序，堆内存在256m,512m,1g,4g的范围内压测。在多核环境下，运行效率明显比serial收集器要好，每次GC花费的时间要少。

4.**Parallel Scavenge**，多线程并行，应用于young区。这款收集器是“吞吐量优先”的，关注点在吞吐量上。吞吐量指的是“处理器用于运行用户代码的时间与处理器总消耗时间的比值”。PS同样会阻塞用户线程，但可通过指定参数来控制最大垃圾收集停顿时间和及直接设置吞吐量大小。当设置“最大垃圾收集停顿时间”时，其实是以牺牲young区大和提高GC频率来换取的（相当于降低了吞吐量），这个参数得根据实际场景来设置。另外PS提供了自适应策略，可以让PS根据上述两个参数来自己调配算法行为。

**压测结论**：针对GCLogAnalysis程序，堆内存在256m,512m,1g,4g的范围内压测。PS和ParNew的行为差距并不大，多核环境下GC效率要比serial收集器好。在JDK８默认GC下，PS和ParOld算法一起使用，有时候会因为自适应策略的问题，会产生majorGC。相比ParNew+CMS，这套组合的Full/majorGc相对多一点点。

5**.Parallel Old收集器**，多线程并发，应用于Old区。从书上了解到ParOld是JDK6开始才提供（CMS在JDK5已经提供）。之前GC组合是PS负责 + serialOld，而serialOld是单线程的，因此不能让PS的“专注吞吐量”发挥最大的作用。现在ParOld是多线程并发的，那么PS+ParOld（JDK8默认）这套组合才算是真正的”专注吞吐量“。既然是关注吞吐量，即用户线程获得CPU资源的时间，那么侧面说明在CPU稀缺的情况下，可以考虑这套GC组合。

6.**CMS收集器**，多线程并发，应用于Old区。CMS关注于”降低用户线程停顿时间“。CMS回收old内存的时候，不再是”停止用户线程直到回收完毕“，而是将垃圾回收分为好几个阶段，其中只有在”初始标记“阶段和”重新标记“阶段需要暂停用户线程，其他阶段则是GC线程和用户线程并发运行。既然CMS是并发运行的，侧面说明该收集器适用于“关注响应用户时间”的情景下。要注意的地方是，GC线程和用户线程并发运行会互相竞争资源，会降低用户程序的吞吐量，如果在CPU资源敏感的情景下，CMS收集器可能并不会有良好的效率。另外，并发运行的行为结果是“一边回收内存，又一边分配内存”，因此当分配速率大于回收速率的时候，会导致FullGC的产生。还有CMS并不会压缩内存，因此当old区无法找到连续区域存储大对象的时候，也会引起fullGC。

**压测结论**：针对GCLogAnalysis程序，堆内存在256m,512m,1g,4g的范围内压测。在内存不大的时候，CMS与parOld比较，CMS两个标记阶段花费时间的确比parOld整体GC花费时间少。在大内存的时候，由于两者都不容易触发majorGC或者fullGC，因此只有上面压测结论中young区的比较。

7.**G1GC**，多线程并发，应用于全堆。与之前的收集器不同，G1对堆的结构有全新的理解，G1把堆分成了很多块大小相等的区域。每个区域可以设置属性来扮演young或old的角色，所以跟以前的收集器相比，young和old没有“绝对区域”这么一个概念。与之前收集器相比，G1回收垃圾不再是全区域收集，而是“回收垃圾最多的块”，G1这个回收特点像“尽可能让每次的GC回收达到最大效果”。基于上诉特点，G1是一款停顿时间可控的垃圾回收器。

**压测结论**：针对GCLogAnalysis程序，堆内存4g压测，与CMS相比，效率上并不存在明显的优势。可能在更大内存的时候，G1效果就好了，毕竟CMS回收时候还是针对全old区的。要注意的是，在压测时候，利用G1GC的堆内存变化图明显比以前GC的堆内存变化图波动要大，G1GC需要用到更大的内存来启动。

**Part2**

从serial到g1的发展，能够看到计算机和互联网发展的一个缩影。从单核到多核，从单线程到多线程，GC也到了利用多线程来提高GC效率的时代。随着关注用户体验，GC的发展思路像是在“为用户程序得到良好的体验”而不断优化，思路也像是从“停顿用户线程，回收全区垃圾”到“用户线程和GC线程并发运行”，再到“在可接受的停顿时间内，回收最多的内存”，只要回收速率跟得上分配速率即可。