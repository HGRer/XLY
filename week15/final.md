# 毕业总结

先表示谢谢老师们的指导。

学习完课程，如果利用课程中学习到的“草图”、“脚手架”的概念，我觉得整个课程的目录下来是一套面对现在分布式市场、“云”的解决方案草图。每个主题课程则老师教会我的脚手架。面对分布式不再是一个模糊而畏惧的态度，而是变成了“我也可以”的态度。除此技术特点之外，去思考老师所讲的真实生产环境和各种技术随着现实业务的演进，让我了解到可以在非技术角度上去思考问题，有种暂时无法言语的感触。

以下是课程的脑图和一些个人了解，技术特点在之前的笔记上有，这次更多是站在整个“课程草图”上去了解这套“解决方案”的结构。

## 一.JVM

### jvm

为**字节码文件**提供了运行环境，通过改变JVM参数来改变运行环境，使得编写的程序（即字节码文件）有不同运行性能。

### 字节码

1.java文件通过编译器编译之后得到的文件。

2.学习了jvm指令集，反编译.class文件之后可以得知当前代码运行的顺序。

3.学习了类在虚拟机中的数据结构，了解到类在虚拟机中由对应的头部、方法区、常量池等组成。因此也首次了解上synchronized关键字是如何给类上锁。

4.在学习了字节码后，思考当前线程在运行一个方法时不再是一个抽象的画面，而是具体到CPU执行到当前字节码文件哪一行。同时学习了JMM模型和线程模型之后，对stackOverflow有了真正的了解。

### 虚拟机内存模型

将内存划分成各个区，每个区提供不同的作用。各个区包括了堆、栈、常量池、方法区，本地方法栈、程序计数器、元数据区等。随着JDK版本的变动，各版本的JMM划分的区域也有变化，但是每个区域划分的变化都离不开实际的功能需求，只是可能表达/表现的方式不同了。

### 类加载

1.类是Java程序运行中的最基本单位。

2.已经学了类的字节码（即类的数据结构），掌握了类的基本结构。

3.了解JVM是如何加载一个类：加载-链接（校验-准备-解析）-初始化-使用-卸载。这是类在JVM的生命周期。

4.将类看作是唯一且可复用资源。学习在代码中利用不同加载器加载某个类过程。

### 堆内存与GC算法

1.堆内存是用来存放对象实例的，这部分占据了大部分内存容量。

2.堆的功能决定了“回收堆内可用内存”是重要且必须的。

3.因此2的需求就决定了垃圾回收算法的诞生。而GC运行效率与业务程序运行的效率息息相关。

4.随着JDK版本的演进，GC算法也发生了演进。根据算法不同的原理与思想以及对堆的数据结构理解，也有了多个版本的垃圾回收算法。

5.GC算法会影响业务程序运行的性能。因此除了兼顾回收速度，在性能方面，算法也出现了串行、并发、并行等不同的版本。

6.根据实际业务程序需求，通过改变JVM参数来改变堆大小、GC算法、GC算法行为等，从而为业务程序带来更好的运行效率。

### 使用工具

使用成熟的工具来查看当前JVM运行的情况。通过工具给出的反馈结果和以及对JVM的了解，对当前JVM运行情况给出诊断。

## 二.NIO

### 关于“高性能”

1.“高性能”这个概念，对我来说，最直观的体验就是用户体验是否良好。比如我打开一个网页，我不喜欢等待很久才能得到看到网站内容。比如GC的时候希望用户程序不会卡顿或者是运行效率明显下降。比如我在公交站上等待公交，我希望公交车很快就可以来。再比如在公交车上，希望道路上不会发生堵车等等。诸如此类例子，“高性能”这个名词无论在计算机中还是在生活中都有具体的体现。

2.当用户体验不够好的时候，分析“不够好”的问题出现在什么地方 -> 分析完后，当前有什么成熟的解决方案或者经验可以使用。

3.根据1和2，Java本身提供了什么样的工具来让我构造一个高性能的程序。

4.在业务场景下，除了Java自身，有无其他的软件或者模式等结合Java程序变成一个高性能的业务程序。

### 线程模型

1.Java中用Thread类来表示Java程序中的线程，是与操作系统中一个线程的映射。在当前版本的JDK中，Java中的线程仍然是最基本的调度单位。

2.Thread实例的生命周期。

3.Thread的调度。（即线程的有限状态机）

4.操作系统本身提供了控制线程的调用，Java语言在此基础上又构建和提供了编程级别的调用。

### 线程安全

1.因为线程之间可以共享资源，因此多线程在涉及到共享资源的场景下，有可能会引起线程安全问题。可能线程之间会竞争资源、可能共享资源在线程的上下文中被其他线程改动了等等。

2.为了保证线程安全，结合Thread类提供的方法以及各种“安全思想”，衍生了挺多可用于保证线程安全的方法、类或者模式。诸如有锁、无锁、关键字Synchronized等等。

3.根据2的描述，JUC并发工具包提供了各种不同原理的线程安全类。在这JUC上，又可以根据业务需求来构建合适的多线程且安全的程序。

### 并发编程

1.随着操作系统提供多种不同的调用，并发编程也演进了不同的IO模型。有阻塞IO模型 -> 非阻塞IO模型 -> IO复用 -> 信号/事件驱动IO模型 ->异步IO模型

2.结合IO模型和多线程，可以让程序在适当场景下带来更高的性能。同时多线程也是把双刃剑，会带来线程安全的问题。

3.线程是操作系统的一种资源，为了减少创建和销毁线程的花销，自然衍生出“可复用线程”的概念，即线程池。

### Netty

在服务器端，网络通信便是一个多线程场景。

学习Netty和Redis之后，回过头来对Netty有了新的思考。

起初Netty利用操作系统内核的非阻塞调用来减少线程在用户态和内核态切换带来的花销，并且专门利用一个线程来处理网络请求，只需要向操作系统注册监听和等待系统通知来处理网络请求即可。

类比到现实中饭店的门童、服务员与厨师的场景，上述无论是现实还是在事实测试下都证明了Netty的这个模型是高性能的。

后面学习了redis中利用单线程处理数据避免线程安全问题，这一个模式有点像netty处理网络请求的模式，都属于单线程，都可以不考虑线程安全问题。

## 三.Spring等各种框架

### Spring

为什么会选用spring？按照第一反应来说，是因为spring框架拥有成熟的生态环境，提供解决问题的方案也很成熟。

后面的课程中理解到“脚手架”这个概念，明白到“成熟的生态环境”指的是Spring提供/整合了很多第三方框架/插件，即这个脚手架提供了许多工具来解决业务问题。

按照这个步骤，理解Spring的重点放在了如何“整合”这么多第三方工具到自身这个脚手架上。

这个时候就回到了以前一开始学习Spring的IOC、AOP、生命周期等知识点。但是已经是站在了不同的角度去学习这些知识点了。

### ORM

我理解的ORM：按照使用习惯和经验来讲，ORM就是讲数据库中的一个表变成Java中的一个类。

现在学完了课程，ORM的理解上升到：对于同一个概念（比如订单），在不同的领域中（例如在数据库、Java）的表达形式会有所不同，ORM则负责将“不同的领域”的“同一个概念”关联起来。

因此按照这个思想，也有了mybatis、hibernate等ORM框架。

### 其他

按照“脚手架”这个概念，当选中了一种脚手架之后，开发模式也会受到这个脚手架的限制。

所以最好能够按照实际业务的需求，选择一种合适的脚手架来提供解决方案。

## 四.数据库

#### SQL

学完课程，对SQL语言理解是：这是专门负责数据存储、查询的语言。即一种用于专门领域的语言。

所以当一个程序，提供了SQL规范的功能，我也可以认为该程序可用于存储数据、查询数据。

#### MySQL

MySQL，起初我的理解仅仅是一个数据库，用来存数据和查数据。

学习完课程后，MySQL我理解成是用于解决存储问题的方案之一。简而言之，MySQL也可以理解成一种“脚手架”。

按照这个“脚手架”的概念，MySql提供了不同的存储引擎，可以根据实际业务来选择。

MySql这个脚手架提供的集群功能，可用来构建高可能、高性能（读写分离）的数据库集群。

#### 分库分表

MySQL不能解决的一个情况是：单库数据量存储过大。所以在这个脚手架之外，利用分库分表的思想来解决单点数据量太大的问题。而结合集群的功能，又能够在分库的情况下提供高可用的特性。

## 五.RPC与微服务

#### RPC

现在对RPC的了解，不是简单的停留在“两个非本地进程之间通信”上。课程中讲了实现RPC需要解决什么，像通信协议、序列化、桩等等。除了这些解决技术点之外，RPC这一个架构，整体看来是解决远程通信的一个方案，具体的实现技术则由各种脚手架提供。

现在看着RPC就像“草图”，“脚手架”则是各种技术套件、框架等。

#### 微服务

未学习相关概念之前，对微服务的理解是：多台实例机器提供相同的服务。

现在学习了RPC和微服务架构架构之后，用下图来辅助我要描述的概念。

“提供业务”这个方框，可以是包括了业务+数据存储。

“对外访问”这个方框，则是为“提供业务”方框提供了访问方式。

假设同一个业务程序部署在多台机器上，这些机器组成了一个业务集群。这个业务集群可以对外提供多个访问地址。

“微服务”方框则是在将多个访问地址管理起来，为第三方访问提供了统一的入口。与此同时，“微服务”为业务集群提供了管理、路由等管理功能。可以这么认为，“微服务”在业务功能基础上，在无侵入业务代码的方式下，又提供了额外的集群管理功能。

![](https://github.com/HGRer/XLY/blob/master/week15/image/123.png)

## 六.分布式缓存与消息队列

在工作上，缓存的使用涉及不到集群，都是随着服务器启动而启动。

学完了课程之后呢，了解到在分布式场景下，缓存也是单独的一个模块，独立于业务系统的程序，不再是我工作时缓存模块嵌套在业务系统中的场景。因此当缓存独立于业务系统，便需要考虑缓存系统的高可用性，也随之有了缓存集群。

面对缓存集群，我觉得跟面对mysql集群、消息队列集群并没有什么区别。这些“集群”都需要面对一些共同问题，例如主从、同步数据、选举master等等，虽然各自的领域不同，但是他们处理问题的原理是相同的。这是我学完缓存集群和消息队列集群后很大的收获。

关于消息队列，最大的收获是：

1.从“系统间通信”和“队列到消息服务”两个角度去思考消息队列的诞生，首次不是从了解各种技术特点去了解消息队列。

2.在工作上，引入消息队列的理由，或者说是学会了去考虑什么样的场景下适合用消息队列。并且已经在工作上实际利用到。