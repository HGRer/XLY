## **必做一**

在配置redis的哨兵模式时，发现在win10上使用docker时遇到了困难，经过助教指导后使用wsl2安装了Ubuntu。

主从复制：一主三从模式，6379作为master，其余均为slave。

Sentinel：在主从复制的基础上，启动了三个Sentinel。一开始是由6379担任master角色，在关闭6379后，由Sentinel集群来决定由6382来担任master。

Cluster：根据网上的教程，创建了Cluster集群。其中创建和Cluster集群的图片放在了redis-cluster文件夹下。

------

## **必做二**

相关代码位于\week12\src\main\java\homework\week12\App.java。

### queue：

根据官网的教程代码，简单地编写了代码。

### topic:

实现了一个publisher，两个subscriber，其中subscriber分别使用不同的方法实现订阅。

------

## **总结**

### redis

上周学习到Redis是作为一个key-value存储系统，其功能类似于数据库。Redis服务器也会遇到与数据库服务器一样遇到同样的问题，比如单点数据量过大、如何实现高可用高并发等问题。

前面学习MySQL时，涉及到数据库集群、高可用、读写分离等的实现，在Redis上也有类似的实现。实现的方式各有不同，但是实现的原理大致相同。

1.读写分离 - 减轻单库/单服务器的读写压力

redis提供了简单的命令slaveof host port来实现主从，在redis-cli客户端就可以实现。如此便可实现“一主多从”的集群模式。

2.因“减轻单库/单服务器的读写压力”引入的“一主多从”的集群模式后，需要考虑在主库或某个从库挂掉后，整个集群对外仍提供服务

redis的sentinel本身也是一个redis服务器，通过简单的配置文件便可以拉起一个sentinel。启动多个sentinel后，各个sentinel会根据配置文件中的主库信息获取到整个主从集群的信息。此后多个sentinel自己也会组成集群，监控主从集群，当主库挂了后，通过投票的方式来选择一个从库来当主库。

3.现在一个可靠的redis集群可以对外提供服务了。若是在数据容量上考虑，这个集群中的主库和从库的单点容量压力会随着数据的变多而增大。

mysql利用了shardingSphere的分片分库的功能实现了对数据库集群的分片分库，从而减少单个数据库的容量压力。而redis提供了cluster来实现分片。需要在启动redis服务器时打开cluster模式。

在启用cluster的模式下，从“一主多从”走向了“多主多从”，作业里面使用了三个主库三个从库。redis服务器在cluster模式下需要两个端口，一个端口负责给客户端访问，另外一个端口负责在cluster集群下通信。

现在在cluster的“多主多从”模式下，再加上sentinel集群各自监控“主从”集群。让最开始学习的单个redis走向了高可用高性能的redis集群。

### 消息队列

“为什么要有消息队列”：1.从系统间通信方式来谈 2.从队列到队列服务来谈。从两个不同的方面来描述消息队列的由来让我受益良多。工作中使用mq的理由便是实现异步处理消息，但是未考虑过为什么mq就适合处理这种情形。

此外，消息队列和RPC两者看似是两种不相关的技术，但是两者要解决的问题有很多是一样的。例如RPC和消息处理网络通信时面对的问题是一样的，RPC能够netty作为网络通信框架，消息队列同样可以使用netty作为网络通信框架。基于这个通信框架上RPC和消息队列又各自侧重不同业务提供不同的功能。

再例如，老师说到activemq的确认机制，就与TCP的确认机制非常相似，大家都使用了累积确认。

另外，JMS协议及其层级图具体描述了在Java程序中可以通过JMS这种协议来进行消息通信。而JMS的层级图则是具体描绘了JMS的编程模型。ConnectionFactory负责创建与消息队列服务器的链接 -> 在此链接上创建会话session -> 在会话上可以与消息队列服务器通信 -> 将参与通信的客户端角色又抽象成MessageConsumer和MessageProducer。

